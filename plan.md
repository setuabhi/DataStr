Day 1: Arrays (Basics)
Arrays are fundamental and highly asked , Start with simple array operations and foundational problems:
  
    Kadane’s algorithm (Maximum subarray sum)
    
    Subarray with given sum

    Merge two sorted arrays
    
    Dutch national flag algorithm (Sort an array of 0s, 1s, and 2s)
    
    Trapping Rain Water
    

Day 2: Arrays (Patterns – Two Pointers & Sliding Window)
Learn two-pointer and sliding-window techniques – powerful for array/string problems
Practice problems that use these patterns:

    Longest Substring Without Repeating Characters (sliding window)
    
    Maximum Sum Subarray of Size <= K (fixed-size sliding window)
    
    Minimum Window Substring (find smallest substring containing all chars)
    
    Longest Repeating Character Replacement (sliding window with replacements)
    
    Sliding Window Maximum (maintaining max in each window)
    

Day 3: Strings (Basics)
Strings are a core topic (manipulation, searching, pattern matching). Begin with simple string puzzles:

    Reverse words in a string
    
    Longest Palindrome in a string
    
    Check if a string is rotated by two places
    
    Roman Number to Integer (parsing problem)
    
    Anagram check (determine if two strings are anagrams)
    

Day 4: Strings (Advanced)
    Practice more complex string problems and common patterns:

    Implement Atoi (string-to-integer conversion)
    
    Search Pattern (KMP Algorithm)
    
    Longest Common Prefix (among array of strings)
    
    Smallest Window in String containing all characters of another (minimum window substring)
    
    Interleaved String check (DP/recursion on strings)
    

Day 5: Linked List (Basics)
Linked lists are frequently tested; start with elementary operations:

    Finding middle element of a linked list
    
    Reverse a linked list
    
    Detect loop in a linked list
    
    Merge two sorted linked lists
    
    Nth node from end of a linked list
    

Day 6: Linked List (Advanced)
Tackle more linked-list puzzles:

    Reverse a linked list in groups of size K
    
    Intersection point of two linked lists (Y-shaped)
    
    Remove loop in a linked list
    
    Check if linked list is a palindrome
    
    Add two numbers represented by linked lists
    

Day 7: Stack & Queue
Study stack/queue problems and classic use-cases:

    Parenthesis Checker (valid parentheses sequence)
    
    Next Greater Element (NGE)
    
    Implement queue using two stacks
    
    Get minimum element from a stack (min-stack design)
    
    LRU Cache (design using stack/queue logic)
    

Day 8: Queue (Advanced)
Practice queue-based and BFS-like problems:

    First non-repeating character in a stream (using queue)
    
    Rotten Oranges (grid BFS problem)
    
    Maximum of all subarrays of size K (sliding window, can use deque)
    
    Circular Tour (Gas Station problem)
    
    Merge K Sorted Lists (use a priority queue/heap)
    

Day 9: Binary Tree (Fundamentals)
Binary trees and traversals are common:

    Print Left View of a Binary Tree
    
    Check if a Binary Tree is a BST
    
    Print Bottom View of a Binary Tree
    
    Level order traversal in spiral form (zig-zag)
    
    Connect Nodes at Same Level (populate next pointers)
    

Day 10: Binary Tree (Advanced)
Cover deeper tree problems:

    Lowest Common Ancestor in a BST
    
    Maximum Path Sum in a Binary Tree
    
    Diameter of a Binary Tree
    
    Height of a Binary Tree (from Top 50 Tree problems)
    Serialize and Deserialize a Binary Tree
    

Day 11: Binary Search Tree (BST)
BST-specific questions:

    Convert Sorted Array to BST
    
    Inorder Successor in BST
    
    K-th Largest Element in a BST
    
    Check and fix swapped nodes in a BST (recover BST)
    
    Merge two BSTs
    

Day 12: Graphs (BFS/DFS)
Basic graph traversal and detection:

    Breadth-First Traversal (BFS) of a Graph
    
    Depth-First Traversal (DFS) of a Graph
    
    Detect cycle in an undirected graph
    
    Connected Components in an undirected graph
    
    Find number of islands (matrix of 0s/1s)
    

Day 13: Graphs (Advanced)
Graph algorithms for weighted or directed graphs:

    Dijkstra’s shortest path algorithm
    
    Minimum Spanning Tree (Kruskal/Prim)
    
    Topological Sort (using DFS or Kahn’s)
    
    Strongly Connected Components (Kosaraju’s or Tarjan’s)
    
    Detect cycle in a directed graph (using DFS/backtracking)
    

Day 14: Heaps/Priority Queue & Misc
Practice heap and related problems:

    Find median in a stream (running median)
    
    Heap Sort algorithm
    
    Merge K sorted linked lists
    
    K-th largest element in a stream
    
    Rearrange characters in a string by frequency (greedy with heap)
    

Day 15: Sorting Problems
Common sorting-related interview tasks:

    Triplet Sum (3Sum)
    
    Merge Overlapping Intervals (sort by start times)
    
    Sort an array of 0s, 1s and 2s
    
    K-th smallest/Largest element in array
    
    Inversion Count (minimum swaps to sort)
    

Day 16: Searching Problems
Key search/binary-search challenges:

    Search in Rotated Sorted Array
    
    Find first and last position of X in sorted array (range search)
    
    Single element in sorted array (every other element appears twice)
    
    Median of two sorted arrays (hard binary search)
    
    K-th smallest/largest in unsorted array (selection algorithm)
    

Day 17: Hashing / Hash Map
Problems using hash tables or frequency counts:

    Longest Consecutive Sequence (array with hashes)
    
    Count distinct elements in every window of size K
    
    All pairs with a given sum (using a hash set/map)
    
    First non-repeating character in a string (stream or hash)
    
    Smallest window in a string containing all characters of another (minimum window substring – again)
    

Day 18: Greedy Algorithms
Classic greedy problems:

    Activity Selection / N Meetings in One Room
    
    Maximum number of toys (to maximize purchase under budget)
    
    Minimize the heights (minimize maximum difference after increment/decrement)
    
    Page Faults in LRU (caching)
    
    Minimize sum of products (pair smallest with largest)
    

Day 19: Dynamic Programming (Easy)
Fundamental DP problems:

    Longest Common Subsequence
    
    Longest Increasing Subsequence
    
    0/1 Knapsack Problem
    
    Coin Change (minimum coins)
    
    Longest Palindromic Subsequence
    

Day 20: Dynamic Programming (Medium)
Intermediate DP problems:

    Edit Distance (Levenshtein distance)
    
    Partition Equal Subset Sum (subset DP)
    
    Egg Dropping Puzzle
    
    Word Break Problem
    
    Optimal Strategy for a Game (optimal play coin game)
    

Day 21: Dynamic Programming (Advanced)
Harder DP puzzles:

    Matrix Chain Multiplication
    
    Longest Increasing Subsequence (n log n version) (practice optimized DP)
    
    Count Palindromic Subsequences
    
    Shortest Common Supersequence
    
    Word Wrap / Text Justification
    

Day 22: Bit Manipulation & Math
Interview bitwise problems:

    Check if a number is power of two
    
    Count set bits in an integer
    
    XOR without using XOR operator (using bit hacks)
    
    Turn off the rightmost set bit of a number
    
    Check or set K-th bit in a number
    

Day 23: Recursion / Backtracking (Basics)
Basic recursion patterns:

    Flood Fill Algorithm (dfs on grid)
    
    Unique Paths (count paths in a grid)
    
    Combination Sum (find combinations that add to target)
    
    Josephus Problem (recursive elimination)
    
    Generate Balanced Parentheses (recursively build)
    
    (similar to Search Pattern source)

Day 24: Recursion / Backtracking (Advanced)
More backtracking problems:

    Subset Sum / Power Set generation (list all subsets)
    
    (via recursion)
    Permutations of a string/array
    
    (permutations implied)
    N-Queens puzzle (place N queens on board)
    
    (as example of hard recursion)
    Sudoku Solver (use backtracking)
    
    (hard constraint problem)
    Word Search (Boggle) (grid recursion)
    

Day 25–30: 

    Consolidation & Extra Practice
    Use the remaining days to review weak topics and solve additional problems in each area above. For example: revisit array and string puzzles, try harder DP or graph problems, and mix in any missed patterns (prefix sums, fast/slow pointers, bitmasking, etc.). The GeeksforGeeks “Top Interview Questions” lists
    contain many more examples. Ensure you cover any gaps by picking 5–10 more problems each day from those collections. (No new topics – just reinforce and practice.)